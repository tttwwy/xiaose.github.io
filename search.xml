<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[线下AUC提升为什么不能带来线上效果提升?]]></title>
    <url>%2F2019-03-03%2F30850.html</url>
    <content type="text"><![CDATA[在推荐系统实践中，我们往往会遇到一个问题：线下AUC提升并不能带来线上效果提升，这个问题在推荐系统迭代的后期往往会更加普遍。 在排除了低级失误bug以后，造成这个问题可能有下面几点原因： 样本 线下评测基于历史出现样本，而线上测试存在新样本。因此线下AUC提升可能只是在历史出现样本上有提升，但是对于线上新样本可能并没有效果。 历史数据本身由老模型产生，本身也是存在偏置的。 包含时间相关特征，存在特征穿越。 评估目标 AUC计算的时候，不仅会涉及同一个用户的不同item，也会涉及不同用户的不同item，而线上排序系统每次排序只针对同一个用户的不同item进行打分。 线上效果只跟相关性有关，是和position等偏置因素无关的。而线下一般是不同position的样本混合训练，因此线上和线下评估不对等。 分布变化：DNN模型相比传统模型，一般得分分布会更平滑，和传统模型相比打分布不一致。而线上有些出价策略依赖了打分分布，例如有一些相关阈值，那么就可能产生影响。这个可能绘制CTR概率分布图来检查。 那么如何解决呢？可以考虑下面的办法： 使用无偏样本作为测试集。随机样本最好，不行的话，最好不要是基于老模型产生的线上样本。 使用gauc等指标，同时从测试集中去除无点击的用户。gauc基于session进行分组。例如对于搜索业务，把一次搜索query对应的一次用户的曝光点击行为作为一个session进行计算。 参考资料https://zhuanlan.zhihu.com/p/52930683https://www.zhihu.com/question/305823078https://zhuanlan.zhihu.com/p/35459467]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
        <tag>推荐系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Character-based Joint Segmentation and POS Tagging for Chinese using Bidirectional RNN-CRF]]></title>
    <url>%2F2017-04-06%2F27292.html</url>
    <content type="text"><![CDATA[Character-based Joint Segmentation and POS Tagging for Chinese using Bidirectional RNN-CRF作者Yan Shao and Christian Hardmeier and Jorg Tiedemann and Joakim Nivre 单位Department of Linguistics and Philology, Uppsala UniversityDepartment of Modern Languages, University of Helsinki 关键词Bi-RNN-CRF，分词，词性标注，汉字embedding 文章来源https://arxiv.org/pdf/1704.01314.pdf 问题如何联合做中文分词和词性标注。 模型 这篇论文首先将双向GRU+CRF这种非常流行的序列标注模型应用到了分词和词性标注任务上。使用了联合训练的方式，即将分词的标签和词性标注的标签拼在一起，同时输出。例如夏天太热这个句子，分词的标签输出是B E S S，词性标注的标签输出是NT NT AD VA,那么联合的标签输出就是B-NT E-NT S-AD S-VA。 同时，这篇论文使用了三种汉字embedding方式 Concatenated N-gram：即使用包含这个字的n-gram词，来作为这个字的embedding,这样相比双向GRU的方式，可以更直接的考虑局部信息 Radicals and Orthographical Features：首先使用了部首信息，作为embedding，其次将汉字作为图像送给CNN，获取字的embedding 公开语料预训练好的字embedding 论文decoding阶段，使用了ensemble方法，把4个不同初始化方式的模型取平均，进行decoding 资源代码：https://github.com/yanshao9798/tagger 简评这篇文章将分词和词性标注进行联合，避免了两个任务间的错误传递问题。同时针对汉字特有的特点，探索了基于部首和汉字图像的embedding方式，对其他中文处理任务也有一定的启发。]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[当AI邂逅艺术：机器写诗综述]]></title>
    <url>%2F2017-01-24%2F15287.html</url>
    <content type="text"><![CDATA[引言什么是艺术？机器的作品能否叫艺术？机器能否取代艺术家？这些问题，相信不同的人，会有不同的答案。很多人认为机器生成的作品只是简单的模仿人类，没有创造性可言，但是人类艺术家，不也是从模仿和学习开始的吗？本文是一篇机器诗歌生成的综述文章，希望能增进大家对这个领域的了解。诗歌是人类文学皇冠上的明珠。我国自《诗经》以后，两千年来的诗篇灿若繁星。让机器自动生成诗歌，一直是人工智能领域一个有挑战性的工作。 基于传统方法的诗歌生成机器诗歌生成的工作，始于20世纪70年代。传统的诗歌生成方法，主要有以下几种： Word Salada（词语沙拉）：是最早期的诗歌生成模型，被称作只是简单将词语进行随机组合和堆砌而不考虑语义语法要求。 基于模板和模式的方法：基于模板的方法类似于完形填空，将一首现有诗歌挖去一些词，作为模板，再用一些其他词进行替换，产生新的诗歌。这种方法生成的诗歌在语法上有所提升，但是灵活性太差。因此后来出现了基于模式的方法，通过对每个位置词的词性，韵律平仄进行限制，来进行诗歌生成。 基于遗传算法的方法：周昌乐等[1]提出并应用到宋词生成上。这里将诗歌生成看成状态空间搜索问题。先从随机诗句开始，然后借助人工定义的诗句评估函数，不断进行评估，进化的迭代，最终得到诗歌。这种方法在单句上有较好的结果，但是句子之间缺乏语义连贯性。 基于摘要生成的方法：严睿等[2]将诗歌生成看成给定写作意图的摘要生成问题，同时加入了诗歌相关的一些优化约束。 基于统计机器翻译的方法：MSRA的何晶和周明[3]将诗歌生成看成一个机器翻译问题，将上一句看成源语言，下一句看成目标语言，用统计机器翻译模型进行翻译，并加上平仄押韵等约束，得到下一句。通过不断重复这个过程，得到一首完整的诗歌。 基于深度学习技术的诗歌生成传统方法非常依赖于诗词领域的专业知识，需要专家设计大量的人工规则，对生成诗词的格律和质量进行约束。同时迁移能力也比较差，难以直接应用到其他文体（唐诗，宋词等）和语言（英文，日文等）。随着深度学习技术的发展，诗歌生成的研究进入了一个新的阶段。 RNNLM基于RNN语言模型[4]的方法，将诗歌的整体内容，作为训练语料送给RNN语言模型进行训练。训练完成后，先给定一些初始内容，然后就可以按照语言模型输出的概率分布进行采样得到下一个词，不断重复这个过程就产生完整的诗歌。Karpathy有一篇文章，非常详细的介绍这个：http://karpathy.github.io/2015/05/21/rnn-effectiveness/ Chinese Poetry Generation with Recurrent Neural NetworksRNNPG模型[5]，首先由用户给定的关键词生成第一句，然后由第一句话生成第二句话，由一，二句话生成第三句话，重复这个过程，直到诗歌生成完成。模型的模型由三部分组成： Convolutional Sentence Model（CSM）：CNN模型，用于获取一句话的向量表示。 Recurrent Context Model (RCM)：句子级别的RNN，根据历史生成句子的向量，输出下一个要生成句子的Context向量。 Recurrent Generation Model (RGM)：字符级别RNN，根据RCM输出的Context向量和该句之前已经生成的字符，输出下一个字符的概率分布。解码的时候根据RGM模型输出的概率和语言模型概率加权以后，生成下一句诗歌，由人工规则保证押韵。 模型结构如下图： 模型生成例子如下图： Chinese Song Iambics Generation with Neural Attention-based Model模型[6]是基于attention的encoder-decoder框架，将历史已经生成的内容作为源语言，将下一句话作为目标语言进行翻译。需要用户提供第一句话，然后由第一句生成第二句，第一，二句生成第三句，并不断重复这个过程，直到生成完整诗歌。基于Attention机制配合LSTM，可以学习更长的诗歌，同时在一定程度上，可以保证前后语义的连贯性。 模型结构如下图： 模型生成例子如下图： Chinese Poetry Generation with Planning based Neural Network模型[8]不需要专家知识，是一个端到端的模型。它试图模仿人类开始写作前，先规划一个写作大纲的过程。整个诗歌生成框架由两部分组成：规划模型和生成模型。 规划模型：将代表用户写作意图的Query作为输入，生成一个写作大纲。写作大纲是一个由主题词组成的序列，第i个主题词代表第i句的主题。 生成模型：基于encoder-decoder框架。有两个encoder,其中一个encoder将主题词作为输入，另外一个encoder将历史生成的句子拼在一起作为输入，由decoder生成下一句话。decoder生成的时候，利用Attention机制，对主题词和历史生成内容的向量一起做打分，由模型来决定生成的过程中各部分的重要性。 前面介绍的几个模型，用户的写作意图，基本只能反映在第一句，随着生成过程往后进行，后面句子和用户写作意图的关系越来越弱，就有可能发生主题漂移问题。而规划模型可以使用户的写作意图直接影响整首诗的生成，因此在一定程度上，避免了主题漂移问题，使整首诗的逻辑语义更为连贯。 总体框架图如下： 生成模型框架图如下： 诗歌图灵测试例子： 现代概念诗歌生成例子： i, Poet: Automatic Poetry Composition through Recurrent Neural Networks with Iterative Polishing Schema模型[7]基于encoder-decoder框架。encoder阶段，用户提供一个Query作为自己的写作意图,由CNN模型获取Query的向量表示。decoder阶段，使用了hierarchical的RNN生成框架，由句子级别和词级别两个RNN组成。 句子级别RNN：输入句子向量表示，输出下一个句子的Context向量。 字符级别RNN：输入Context向量和历史生成字符，输出下一个字符的概率分布。当一句生成结束的时候，字符级别RNN的最后一个向量，作为表示这个句子的向量，送给句子级别RNN。 这篇文章一个比较有意思的地方，是想模拟人类写诗反复修改的过程，加入了打磨机制。反复迭代来提高诗歌生成质量。 总体框架图如下： Generating Topical Poetry模型[9]基于encoder-decoder框架，分为两步。先根据用户输入的关键词得到每句话的最后一个词，这些词都押韵且与用户输入相关。再将这些押韵词作为一个序列，送给encoder,由decoder生成整个诗歌。这种机制一方面保证了押韵，另外一方面，和之前提到的规划模型类似，在一定程度上避免了主题漂移问题。模型框架图如下： 生成例子如下： SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient模型[10]将图像中的对抗生成网络，用到文本生成上。生成网络是一个RNN，直接生成整首诗歌。而判别网络是一个CNN。用于判断这首诗歌是人写的，还是机器生成的，并通过强化学习的方式，将梯度回传给生成网络。模型框架图如下： 总结从传统方法到深度学习，诗歌生成技术有了很大发展，甚至在一定程度上，已经可以产生普通人真假难辨的诗歌。但是目前诗歌生成技术，学习到的仍然只是知识的概率分布，即诗句内，诗句间的搭配规律。而没有学到诗歌蕴含思想感情。因此尽管生成的诗歌看起来有模有样，但是仍然感觉只是徒有其表，缺乏一丝人的灵性。另外一方面，诗歌不像机器翻译有BLEU作为评价指标，目前仍然依赖人工的主观评价，缺乏可靠的自动评估方法，因此模型优化的目标函数和主观的诗歌评价指标之间，存在较大的gap，也影响了诗歌生成质量的提高。AlphaGo已经可以击败顶尖人类选手，但是在诗歌生成上，机器尚有很长的路要走。 参考文献[1] 一种宋词自动生成的遗传算法及其机器实现[2] i,Poet: Automatic Chinese Poetry Composition through a Generative Summarization Framework under Constrained Optimization[3] Generating Chinese Classical Poems with Statistical Machine Translation Models[4] Recurrent neural network based language model[5] Chinese Poetry Generation with Recurrent Neural Networks[6] Chinese Song Iambics Generation with Neural Attention-based Model[7] i, Poet: Automatic Poetry Composition through Recurrent Neural Networks with Iterative Polishing Schema[8] Chinese Poetry Generation with Planning based Neural Network[9] Generating Topical Poetry[10] SeqGAN: Sequence Generative Adversarial Nets with Policy Gradient]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
        <tag>NLP</tag>
        <tag>综述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何获取最新的深度学习资源]]></title>
    <url>%2F2017-01-15%2F5503.html</url>
    <content type="text"><![CDATA[很多刚入门深度学习的朋友，往往不知道该如何获取最新的深度学习资源，包括资讯，论文，学习资料等等，有问题也不知道该与谁交流。因此这里分享一些相关途径，希望对大家的学习有所帮助。 微信公众号有很多和深度学习相关的公众号，对学术相关进展的跟进都很及时，可以考虑有选择的关注： 机器之心 智能立方: paperweekly 哈工大scir 将门创投 炼丹实验室 机器学习研究会 AI科技评论 全球人工智能 深度学习大讲堂 邮箱订阅通过邮箱，订阅一些资源的推送，是很有必要的： Arxiv：计算机领域，特别是深度学习领域的最新论文，一般都会先出现在Arxiv上，除了天天到Arxiv相关类别刷论文之外，也可以通过邮箱订阅自己感兴趣的类别：https://arxiv.org/help/subscribe 好东西传送门：包含机器学习日报，NLP日报，大数据日报，Python日报等很实用的内容，建议订阅：http://memect.com/ 大牛的最新Paper：可以通过Google学术，订阅一些深度学习领域大牛的论文，这样一旦他们有新论文，有可以通过邮件及时得到通知,下面是我的一些订阅，不全，仅供参考： Geoffrey Hinton Yann LeCun Yoshua Bengio Andrej Karpathy andrew Y ng Richard Socher Tomas Mikolov Oriol Vinyals Percy Liang Jason Weston Hang Li Tie-Yan Liu 知乎专栏知乎上有很多和深度学习相关的专栏，而且在知乎上可以很方便的和作者进行互动交流，也是一个很方便的方式，下面是一些我订阅的专栏： 炼丹实验室 机器之心 超智能体 PaperWeekly 深度学习：从入门到放弃 智能单元 深度学习大讲堂 网站这里收藏了一些不错的和深度学习相关的资源网站，可以参考：http://rsarxiv.github.io, 经常包含一些最新的Deep Learning in NLP论文中文简介http://nlp.hivefire.com ，包含最新的NLP资讯和论文https://github.com/dennybritz/deeplearning-papernotes ，作者在Google Brain，会经常更新一些自己读论文的笔记。https://www.reddit.com/r/MachineLearning/ ,Reddit的机器学习版，氛围活跃，大牛云集。 微信交流群 PaperWeekly: 想加群，请联系微信号：zhangjun168305, 群里的交流活跃，学术氛围很好。 将门微信群： 里面大牛云集，想加群，请加群请关注将门创投的订阅号，里面有入群方式。 社交网络国内大牛一般是微博，国外大牛一般是Twitter,关注一下他们，可以了解到很多第一手的消息。 上面是我平时收集深度学习论文和资讯的方式总结。我觉得更容易面临的问题，不是信息匮乏，而是信息负载，因此在有限的时间里，学会选择适合的阅读内容，更为重要。]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Theano调试技巧]]></title>
    <url>%2F2017-01-11%2F15149.html</url>
    <content type="text"><![CDATA[Theano是最老牌的深度学习库之一。它灵活的特点使其非常适合学术研究和快速实验，但是它难以调试的问题也遭到过无数吐槽。其实Theano本身提供了很多辅助调试的手段，下面就介绍一些Theano的调试技巧，让Theano调试不再难。而关于深度学习的通用调试技巧，请参见我之前的文章：[深度学习调参技巧]。 以下的技巧和代码均在Theano 0.8.2 上测试通过，不保证在更低的版本上也可以适用。 如何定位出错位置Theano的网络在出错的时候，往往会提供一些出错信息。但是出错信息往往非常模糊，让人难以直接看出具体是哪一行代码出现了问题。大家看下面的例子：12345678910import theanoimport theano.tensor as Timport numpy as npx = T.vector()y = T.vector()z = x + xz = z + yf = theano.function([x, y], z)f(np.array([1,2],dtype=theano.config.floatX), np.array([3,4,5],dtype=theano.config.floatX)) 将代码保存到test.py文件中，在命令行中执行：1THEANO_FLAGS="device=gpu0,floatX=float32" python test.py 输出结果如下：1234567891011121314151617Traceback (most recent call last): File "test.py", line 10, in &lt;module&gt; print f(np.array([1,2],dtype='float32'), np.array([3,4,5],dtype='float32')) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/function_module.py", line 871, in __call__ storage_map=getattr(self.fn, 'storage_map', None)) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 314, in raise_with_op reraise(exc_type, exc_value, exc_trace) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/function_module.py", line 859, in __call__ outputs = self.fn()ValueError: GpuElemwise. Input dimension mis-match. Input 1 (indices start at 0) has shape[0] == 2, but the output size on that axis is 3.Apply node that caused the error: GpuElemwise&#123;Composite&#123;((i0 + i1) + i0)&#125;&#125;[(0, 0)](GpuFromHost.0, GpuFromHost.0)Toposort index: 2Inputs types: [CudaNdarrayType(float32, vector), CudaNdarrayType(float32, vector)]Inputs shapes: [(3,), (2,)]Inputs strides: [(1,), (1,)]Inputs values: [CudaNdarray([ 3. 4. 5.]), CudaNdarray([ 1. 2.])]Outputs clients: [[HostFromGpu(GpuElemwise&#123;Composite&#123;((i0 + i1) + i0)&#125;&#125;[(0, 0)].0)]]HINT: Re-running with most Theano optimization disabled could give you a back-trace of when this node was created. This can be done with by setting the Theano flag 'optimizer=fast_compile'. If that does not work, Theano optimizations can be disabled with 'optimizer=None'.HINT: Use the Theano flag 'exception_verbosity=high' for a debugprint and storage map footprint of this apply node. 比较有用的信息是：Input dimension mis-match，但是具体出问题在哪里，仍然让人一头雾水。因为Theano的计算图进行了一些优化，导致出错的时候难以与原始代码对应起来。想解决这个也很简单，就是关闭计算图的优化功能。可以通过THEANO_FLAGS的optimizer,它的默认值是”fast_run”，代表最大程度的优化，我们平时一般就使用这个，但是如果想让调试信息更详细，我们就需要关闭一部分优化:fast_compile或者关闭全部优化：None，这里我们将optimizer设置成”None”，执行如下命令：1THEANO_FLAGS="device=gpu0,floatX=float32,optimizer=None" python test.py 结果如下：1234567891011121314151617181920212223Traceback (most recent call last): File "test.py", line 10, in &lt;module&gt; print f(np.array([1,2],dtype='float32'), np.array([3,4,5],dtype='float32')) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/function_module.py", line 871, in __call__ storage_map=getattr(self.fn, 'storage_map', None)) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 314, in raise_with_op reraise(exc_type, exc_value, exc_trace) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/function_module.py", line 859, in __call__ outputs = self.fn()ValueError: Input dimension mis-match. (input[0].shape[0] = 3, input[1].shape[0] = 2)Apply node that caused the error: Elemwise&#123;add,no_inplace&#125;(&lt;TensorType(float32, vector)&gt;, &lt;TensorType(float32, vector)&gt;)Toposort index: 0Inputs types: [TensorType(float32, vector), TensorType(float32, vector)]Inputs shapes: [(3,), (2,)]Inputs strides: [(4,), (4,)]Inputs values: [array([ 3., 4., 5.], dtype=float32), array([ 1., 2.], dtype=float32)]Outputs clients: [[Elemwise&#123;add,no_inplace&#125;(Elemwise&#123;add,no_inplace&#125;.0, &lt;TensorType(float32, vector)&gt;)]]Backtrace when the node is created(use Theano flag traceback.limit=N to make it longer): File "test.py", line 7, in &lt;module&gt; z = y + xHINT: Use the Theano flag 'exception_verbosity=high' for a debugprint and storage map footprint of this apply node. 可以看到，这次直接提示出错的位置在代码的第7行：z = y + x，这个是不是方便很多了呢？ 如何打印中间结果下面分别介绍Test Values和Print两种方法。 使用Test Values我曾见过有人为了保证中间运算的实现没有问题，先用numpy实现了一遍，检查每一步运算结果符合预期以后，再移值改成Theano版的，其实大可不必这么折腾。Theano在0.4.0以后，加入了test values机制，简单来说，就是在计算图编译之前，我们可以给symbolic提供一个具体的值，即test_value，这样Theano就可以将这些数据，代入到symbolic表达式的计算过程中，从而完成计算过程的验证，并可以打印出中间过程的运算结果。大家看下面的例子：123456789101112import theanoimport theano.tensor as Timport numpy as npx = T.vector()x.tag.test_value = np.array([1,2],dtype=theano.config.floatX)y = T.vector() y.tag.test_value = np.array([3,4,5],dtype=theano.config.floatX)z = x + xprint z.tag.test_valuez = z + yprint z.tag.test_valuef = theano.function([x, y], z) 运行的时候，需要注意，如果需要使用test_value,那么需要设置一下compute_test_value的标记，有以下几种 off: 关闭，建议在调试没有问题以后，使用off，以提高程序速度。 ignore: test_value计算出错，不会报错 warn: test_value计算出错，进行警告 raise: test_value计算出错，会产出错误 pdb: test_value计算出错，会进入pdb调试。pdb是python自带的调试工具，在pdb里面可以单步查看各变量的值，甚至执行任意python代码，非常强大，如果想看中间过程，又懒得打太多print，那么可以import pdb然后在你想设断点的地方加上：pdb.set_trace()，后面可以用指令n单步，c继续执行。更详细的介绍可以参考这里：https://docs.python.org/2/library/pdb.html 下面继续回到test_value，我们将test_value值修改成warn，执行：1THEANO_FLAGS="device=gpu0,floatX=float32,compute_test_value=warn" python test.py 结果如下：1234567891011121314[ 2. 4.]log_thunk_trace: There was a problem executing an Op.Traceback (most recent call last): File "test.py", line 12, in &lt;module&gt; z = z + y File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/tensor/var.py", line 135, in __add__ return theano.tensor.basic.add(self, other) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/op.py", line 668, in __call__ required = thunk() File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/op.py", line 883, in rval fill_storage() File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/cc.py", line 1707, in __call__ reraise(exc_type, exc_value, exc_trace) File "&lt;string&gt;", line 2, in reraiseValueError: Input dimension mis-match. (input[0].shape[0] = 2, input[1].shape[0] = 3) 可以看到，第一个z的值[2,4]被print了出来，同时在test_value的帮助下，错误信息还告诉我们在执行z = z + y 这一行的时候有问题。因此test_value也可以起到，检测哪一行出错的功能。小技巧: 人工一个个构造test_value,实在太麻烦，因此可以考虑在训练开始前，从训练数据中随机选一条，作为test_value,这样还能辅助检测，训练数据有没有问题。 使用Print不过test_value对scan支持的不好，而如果网络包含RNN的话，scan一般是不可或缺的。那么如何打印出scan在循环过程中的中间结果呢？这里我们可以使用theano.printing.Print()，代码如下：1234567891011import theanoimport theano.tensor as Timport numpy as npx = T.vector()y = T.vector()z = x + xz = theano.printing.Print('z1')(z)z = z + yz = theano.printing.Print('z2')(z)f = theano.function([x, y], z)f(np.array([1,2],dtype=theano.config.floatX),np.array([1,2],dtype=theano.config.floatX)) 执行：1THEANO_FLAGS="device=gpu0,floatX=float32" python test.py 结果如下：12z1 __str__ = [ 2. 4.]z2 __str__ = [ 3. 6.] 不过下面有几点需要注意一下： 因为theano是基于计算图的，因此各变量在计算图中被调用执行的顺序，不一定和原代码的顺序一样，因此变量Print出来的顺序也是无法保证的。 Print方法，会比较严重的拖慢训练的速度，因此最终用于训练的代码，最好把Print去除。 Print方法会阻止一些计算图的优化，包括一些结果稳定性的优化，因此如果程序出现Nan问题，可以考虑把Print去除，再看看。 如何处理NanNan是我们经常遇到的一个问题，我之前的文章：深度学习网络调试技巧 提到了如何处理Nan问题，其中最重要的步骤，是确定Nan最开始出现的位置。一个比较暴力的方法，是打印出变量的中间结果，看看Nan是从哪里开始的，不过这样工作量有点太大了。所以这里介绍另外一个比较省事的方法：NanGuardMode。NanGuardMode会监测指定的function，是否在计算过程中出现nan,inf。如果出现，会立刻报错，这时配合前面提到的optimizer=None，我们就可以直接定位到，具体是哪一行代码最先出现了Nan问题。代码如下：1234567891011121314import theanoimport theano.tensor as Timport numpy as npfrom theano.compile.nanguardmode import NanGuardModex = T.matrix()w = theano.shared(np.random.randn(5, 7).astype(theano.config.floatX))y = T.dot(x, w)fun = theano.function( [x], y,mode=NanGuardMode(nan_is_error=True,inf_is_error=True, big_is_error=True))infa = np.tile( (np.asarray(100.) ** 1000000).astype(theano.config.floatX), (3, 5))fun(infa) 执行：1THEANO_FLAGS="device=gpu0,floatX=float32,optimizer=None" python test.py 结果如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344Traceback (most recent call last): File "test.py", line 12, in &lt;module&gt; f(np.array([1,2],dtype='float32'),np.array([0,0],dtype='float32')) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/function_module.py", line 859, in __call__ outputs = self.fn()Backtrace when the node is created(use Theano flag traceback.limit=N to make it longer): File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 1014, in f raise_with_op(node, *thunks) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 314, in raise_with_op reraise(exc_type, exc_value, exc_trace) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 1012, in f wrapper(i, node, *thunks) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/nanguardmode.py", line 307, in nan_check File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/gof/link.py", line 1012, in f wrapper(i, node, *thunks) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/nanguardmode.py", line 302, in nan_check do_check_on(x[0], node, fn, True) File "/home/wangzhe/anaconda2/lib/python2.7/site-packages/theano/compile/nanguardmode.py", line 272, in do_check_on raise AssertionError(msg)AssertionError: Inf detectedBig value detectedNanGuardMode found an error in an input of this node.Node:dot(&lt;TensorType(float32, matrix)&gt;, HostFromGpu.0)The input variable that cause problem:dot [id A] '' |&lt;TensorType(float32, matrix)&gt; [id B] |HostFromGpu [id C] '' |&lt;CudaNdarrayType(float32, matrix)&gt; [id D]Apply node that caused the error: dot(&lt;TensorType(float32, matrix)&gt;, HostFromGpu.0)Toposort index: 1Inputs types: [TensorType(float32, matrix), TensorType(float32, matrix)]Inputs shapes: [(3, 5), (5, 7)]Inputs strides: [(20, 4), (28, 4)]Inputs values: ['not shown', 'not shown']Outputs clients: [['output']]Backtrace when the node is created(use Theano flag traceback.limit=N to make it longer): File "test.py", line 8, in &lt;module&gt; y = T.dot(x, w)HINT: Use the Theano flag 'exception_verbosity=high' for a debugprint and storage map footprint of this apply node. 可以看到，是y = T.dot(x, w)这一行，产生的Nan. 其他上面的几个技巧，相信可以解决大部分Theano调试中遇到的问题. 同时我们在用Theano实现一些网络结构，例如LSTM的时候，除了直接参考论文之外，这里强烈推荐参考keras进行实现。keras是一个更顶层的库，同时支持Theano和Tensorflow作为后台，里面大部分模型的实现都很可靠，可以学习和参考。 参考资料 http://deeplearning.net/software/theano/library/compile/nanguardmode.html#nanguardmode http://deeplearning.net/software/theano/tutorial/debug_faq.html]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习调参技巧]]></title>
    <url>%2F2017-01-04%2F53197.html</url>
    <content type="text"><![CDATA[之前曾经写过一篇文章，讲了一些深度学习训练的技巧，其中包含了部分调参心得：深度学习训练心得。不过由于一般深度学习实验，相比普通机器学习任务，时间较长，因此调参技巧就显得尤为重要。同时个人实践中，又有一些新的调参心得，因此这里单独写一篇文章，谈一下自己对深度学习调参的理解，大家如果有其他技巧，也欢迎多多交流。 好的实验环境是成功的一半由于深度学习实验超参众多，代码风格良好的实验环境，可以让你的人工或者自动调参更加省力，有以下几点可能需要注意： 将各个参数的设置部分集中在一起。如果参数的设置分布在代码的各个地方，那么修改的过程想必会非常痛苦。 可以输出模型的损失函数值以及训练集和验证集上的准确率。 可以考虑设计一个子程序，可以根据给定的参数，启动训练并监控和周期性保存评估结果。再由一个主程序，分配参数以及并行启动一系列子程序。 画图画图是一个很好的习惯，一般是训练数据遍历一轮以后，就输出一下训练集和验证集准确率。同时画到一张图上。这样训练一段时间以后，如果模型一直没有收敛，那么就可以停止训练，尝试其他参数了，以节省时间。如果训练到最后，训练集，测试集准确率都很低，那么说明模型有可能欠拟合。那么后续调节参数方向，就是增强模型的拟合能力。例如增加网络层数，增加节点数，减少dropout值，减少L2正则值等等。如果训练集准确率较高，测试集准确率比较低，那么模型有可能过拟合，这个时候就需要向提高模型泛化能力的方向，调节参数。 从粗到细分阶段调参实践中，一般先进行初步范围搜索，然后根据好结果出现的地方，再缩小范围进行更精细的搜索。 建议先参考相关论文，以论文中给出的参数作为初始参数。至少论文中的参数，是个不差的结果。 如果找不到参考，那么只能自己尝试了。可以先从比较重要，对实验结果影响比较大的参数开始，同时固定其他参数，得到一个差不多的结果以后，在这个结果的基础上，再调其他参数。例如学习率一般就比正则值，dropout值重要的话，学习率设置的不合适，不仅结果可能变差，模型甚至会无法收敛。 如果实在找不到一组参数，可以让模型收敛。那么就需要检查，是不是其他地方出了问题，例如模型实现，数据等等。可以参考我写的深度学习网络调试技巧 提高速度调参只是为了寻找合适的参数，而不是产出最终模型。一般在小数据集上合适的参数，在大数据集上效果也不会太差。因此可以尝试对数据进行精简，以提高速度，在有限的时间内可以尝试更多参数。 对训练数据进行采样。例如原来100W条数据，先采样成1W，进行实验看看。 减少训练类别。例如手写数字识别任务，原来是10个类别，那么我们可以先在2个类别上训练，看看结果如何。 #超参数范围建议优先在对数尺度上进行超参数搜索。比较典型的是学习率和正则化项，我们可以从诸如0.001 0.01 0.1 1 10，以10为阶数进行尝试。因为他们对训练的影响是相乘的效果。不过有些参数，还是建议在原始尺度上进行搜索，例如dropout值: 0.3 0.5 0.7)。 经验参数这里给出一些参数的经验值，避免大家调参的时候，毫无头绪。 learning rate: 1 0.1 0.01 0.001, 一般从1开始尝试。很少见learning rate大于10的。学习率一般要随着训练进行衰减。衰减系数一般是0.5。 衰减时机，可以是验证集准确率不再上升时，或固定训练多少个周期以后。不过更建议使用自适应梯度的办法，例如adam,adadelta,rmsprop等，这些一般使用相关论文提供的默认值即可，可以避免再费劲调节学习率。对RNN来说，有个经验，如果RNN要处理的序列比较长，或者RNN层数比较多，那么learning rate一般小一些比较好，否则有可能出现结果不收敛，甚至Nan等问题。 网络层数： 先从1层开始。 每层结点数： 16 32 128，超过1000的情况比较少见。超过1W的从来没有见过。 batch size: 128上下开始。batch size值增加，的确能提高训练速度。但是有可能收敛结果变差。如果显存大小允许，可以考虑从一个比较大的值开始尝试。因为batch size太大，一般不会对结果有太大的影响，而batch size太小的话，结果有可能很差。 clip c(梯度裁剪): 限制最大梯度,其实是value = sqrt(w1^2+w2^2….),如果value超过了阈值，就算一个衰减系系数,让value的值等于阈值: 5,10,15 dropout： 0.5 L2正则：1.0，超过10的很少见。 词向量embedding大小：128，256 正负样本比例： 这个是非常忽视，但是在很多分类问题上，又非常重要的参数。很多人往往习惯使用训练数据中默认的正负类别比例，当训练数据非常不平衡的时候，模型很有可能会偏向数目较大的类别，从而影响最终训练结果。除了尝试训练数据默认的正负类别比例之外，建议对数目较小的样本做过采样，例如进行复制。提高他们的比例，看看效果如何，这个对多分类问题同样适用。在使用mini-batch方法进行训练的时候，尽量让一个batch内，各类别的比例平衡，这个在图像识别等多分类任务上非常重要。 自动调参人工一直盯着实验，毕竟太累。自动调参当前也有不少研究。下面介绍几种比较实用的办法： Gird Search. 这个是最常见的。具体说，就是每种参数确定好几个要尝试的值，然后像一个网格一样，把所有参数值的组合遍历一下。优点是实现简单暴力，如果能全部遍历的话，结果比较可靠。缺点是太费时间了，特别像神经网络，一般尝试不了太多的参数组合。 Random Search。Bengio在Random Search for Hyper-Parameter Optimization中指出，Random Search比Gird Search更有效。实际操作的时候，一般也是先用Gird Search的方法，得到所有候选参数，然后每次从中随机选择进行训练。 Bayesian Optimization. 贝叶斯优化，考虑到了不同参数对应的实验结果值，因此更节省时间。和网络搜索相比简直就是老牛和跑车的区别。具体原理可以参考这个论文： Practical Bayesian Optimization of Machine Learning Algorithms ，这里同时推荐两个实现了贝叶斯调参的Python库，可以上手即用： https://github.com/jaberg/hyperopt, 比较简单。 https://github.com/fmfn/BayesianOptimization， 比较复杂，支持并行调参。 总结 合理性检查，确定模型，数据和其他地方没有问题。 训练时跟踪损失函数值，训练集和验证集准确率。 使用Random Search来搜索最优超参数，分阶段从粗（较大超参数范围训练较少周期）到细（较小超参数范围训练较长周期）进行搜索。 参考资料这里列了一些参数资料，大家有时间，可以进一步阅读。Practical recommendations for gradient-based training of deep architectures by Yoshua Bengio (2012)Efficient BackProp, by Yann LeCun, Léon Bottou, Genevieve Orr and Klaus-Robert MüllerNeural Networks: Tricks of the Trade, edited by Grégoire Montavon, Geneviève Orr, and Klaus-Robert Müller.]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习训练个人心得]]></title>
    <url>%2F2016-10-01%2F52515.html</url>
    <content type="text"><![CDATA[参数初始化。下面几种方式,随便选一个,结果基本都差不多。但是一定要做。否则可能会减慢收敛速度，影响收敛结果，甚至造成Nan等一系列问题。n_in为网络的输入大小，n_out为网络的输出大小，n为n_in或(n_in+n_out)*0.5Xavier初始法论文：http://jmlr.org/proceedings/papers/v9/glorot10a/glorot10a.pdfHe初始化论文：https://arxiv.org/abs/1502.01852 uniform均匀分布初始化： w = np.random.uniform(low=-scale, high=scale, size=[n_in,n_out]) Xavier初始法，适用于普通激活函数(tanh,sigmoid)：scale = np.sqrt(3/n) He初始化，适用于ReLU：scale = np.sqrt(6/n) normal高斯分布初始化： w = np.random.randn(n_in,n_out) * stdev # stdev为高斯分布的标准差，均值设为0 Xavier初始法，适用于普通激活函数 (tanh,sigmoid)：stdev = np.sqrt(n) He初始化，适用于ReLU：stdev = np.sqrt(2/n) svd初始化：对RNN有比较好的效果。参考论文：https://arxiv.org/abs/1312.6120 数据预处理方式 zero-center ,这个挺常用的.X -= np.mean(X, axis = 0) # zero-centerX /= np.std(X, axis = 0) # normalize PCA whitening,这个用的比较少. 训练技巧 要做梯度归一化,即算出来的梯度除以minibatch size clip c(梯度裁剪): 限制最大梯度,其实是value = sqrt(w1^2+w2^2….),如果value超过了阈值,就算一个衰减系系数,让value的值等于阈值: 5,10,15 dropout对小数据防止过拟合有很好的效果,值一般设为0.5,小数据上dropout+sgd在我的大部分实验中，效果提升都非常明显.因此可能的话，建议一定要尝试一下。 dropout的位置比较有讲究, 对于RNN,建议放到输入-&gt;RNN与RNN-&gt;输出的位置.关于RNN如何用dropout,可以参考这篇论文:http://arxiv.org/abs/1409.2329 adam,adadelta等,在小数据上,我这里实验的效果不如sgd, sgd收敛速度会慢一些，但是最终收敛后的结果，一般都比较好。如果使用sgd的话,可以选择从1.0或者0.1的学习率开始,隔一段时间,在验证集上检查一下,如果cost没有下降,就对学习率减半. 我看过很多论文都这么搞,我自己实验的结果也很好. 当然,也可以先用ada系列先跑,最后快收敛的时候,更换成sgd继续训练.同样也会有提升.据说adadelta一般在分类问题上效果比较好，adam在生成问题上效果比较好。 除了gate之类的地方,需要把输出限制成0-1之外,尽量不要用sigmoid,可以用tanh或者relu之类的激活函数.1. sigmoid函数在-4到4的区间里，才有较大的梯度。之外的区间，梯度接近0，很容易造成梯度消失问题。2. 输入0均值，sigmoid函数的输出不是0均值的。 rnn的dim和embdding size,一般从128上下开始调整. batch size,一般从128左右开始调整.batch size合适最重要,并不是越大越好. word2vec初始化,在小数据上,不仅可以有效提高收敛速度,也可以可以提高结果. 尽量对数据做shuffle LSTM 的forget gate的bias,用1.0或者更大的值做初始化,可以取得更好的结果,来自这篇论文:http://jmlr.org/proceedings/papers/v37/jozefowicz15.pdf, 我这里实验设成1.0,可以提高收敛速度.实际使用中,不同的任务,可能需要尝试不同的值. Batch Normalization据说可以提升效果，不过我没有尝试过，建议作为最后提升模型的手段，参考论文：Accelerating Deep Network Training by Reducing Internal Covariate Shift 如果你的模型包含全连接层（MLP），并且输入和输出大小一样，可以考虑将MLP替换成Highway Network,我尝试对结果有一点提升，建议作为最后提升模型的手段，原理很简单，就是给输出加了一个gate来控制信息的流动，详细介绍请参考论文: http://arxiv.org/abs/1505.00387 来自@张馨宇的技巧：一轮加正则，一轮不加正则，反复进行。 EnsembleEnsemble是论文刷结果的终极核武器,深度学习中一般有以下几种方式 同样的参数,不同的初始化方式 不同的参数,通过cross-validation,选取最好的几组 同样的参数,模型训练的不同阶段，即不同迭代次数的模型。 不同的模型,进行线性融合. 例如RNN和传统模型.]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用word2vec训练的向量来辅助模型训练]]></title>
    <url>%2F2016-08-15%2F18396.html</url>
    <content type="text"><![CDATA[使用word2vec工具在外部大规模语料上训练得到的向量，可以有效的辅助深度学习模型训练，提高结果。但是实际使用的时候，有很多方式可供选择。 直接用word2vec向量初始化模型embedding,训练的时候允许embedding向量更新。这个方法最为常用，但是遇到不在训练语料中的词，就不能借助外部word2vec向量了。 word2vec向量，先连接全连接层（可以是多层），转化后的向量再作为模型的embedding,训练的时候，word2vec向量保持不变，允许全连接层的参数更新。这个方法，哪怕遇到不在训练语料中的词，只要这个词在外部大规模语料中，能得到word2vec向量，那么就没问题。同时因为word2vec向量在训练的时候固定，因此模型训练涉及的参数会大大减少。 因为word2vec向量的分布，和模型实际需要的向量分布，可能存在差异，因此这个全连接层的作用，就是对word2vec向量的分布进行调整，让他尽可能接近模型需要的向量分布。 将word2vec向量拷贝，得到向量A和向量B，训练的时候，向量A保持不变，允许向量B的参数更新，最终embedding向量是A和B的平均。这个idea的想法，其实是限制word2vec向量的调整，避免调整的时候，太偏离原始向量。 第一轮训练，用Google News训练好的Word2vec初始化embedding,对未知词随机初始化embedding,在训练的时候,固定住word2vec初始化的embedding,而允许未知词的embedding进行调整 第二轮训练，允许所有embedding调整,继续训练这个idea也可以很好的处理未知词，第一轮的时候，因为固定了word2vec向量，因此模型会尽可能基于word2vec向量的分布来调整自己的参数。但是可能分布差异太大，导致模型参数无论怎么调整，都得不到最好结果。因此第二轮的时候，允许word2vec向量进行适当调整。 参考论文 2016-AAAI-Building End-to-End Dialogue Systems Using Generative Hierarchical Neural Network Models 2014-EMNLP-Convolutional Neural Networks for Sentence Classification]]></content>
      <tags>
        <tag>原创</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》读书笔记]]></title>
    <url>%2F2015-05-16%2F36999.html</url>
    <content type="text"><![CDATA[这本书是一本非常经典的书，作者是有硅谷创业教父之称的Paul Graham，书中介绍了作者对黑客精神的看法，鼓励我们保持独立思考的精神，同时介绍了创业公司相比传统公司的种种优点，也谈到了自己对设计，对编程语言等的看法。非常具有启发性 为什么书呆子不受欢迎这一章，作者从自己的角度，分析了为什么书呆子不受欢迎。因为相比让自己受欢迎，他们更愿意把精力放到让自己聪明。让自己受欢迎，需要投入大量的精力，只有极少数人能同时分出精力做到这两者。被一群孩子成群结队的欺负，并不是因为做错了什么，只是因为这一伙人需要一起找一件事情做，而欺负书呆子是一个安全的事情。 黑客与画家作者指出黑客与画家等创作者很像，而不是科学家，并提出了以下几个观点。 都是创作者，试图创作出优秀的作品，本质上并不是在做研究。创作者和科学家是不同的。无论是大学的实验室还是大公司，黑客都很难做自己喜欢的事情，去创业公司，也会有很多麻烦事需要应付。有一份活命的白天工作+晚上的自由自在，是一个不错的办法。 应该通过实践，范例学习编程。 逐步完成，再慢慢填入细节。避免过度设计。 考虑心里周期，以根据不同的事情，找出不同的应对方法。把消灭bug这种轻松工作留到最后解决。 合作开发软件，最好是把项目分割成严格定义的模块，每个模块由一个人明确负责。模块与模块的接口精心设计。 换位思考，考虑用户的人性需要。判断是否有这个能力的方法就是看怎么向没有技术背景的人解释技术问题。 不能说的话针对所谓“不能说的话”，作者给出了一些方法，来找出哪些话是不能说的。 部分情况下的真话。 异端邪说。很多看似叛逆的异端邪说，早就潜伏在思维深处，如果暂时着装自我审查意识，它们就会第一个浮现出来。 时空差异。通过回顾过去，过去与现在，东方与西方等等不同观点，进行对比。所有年代所有地方都基本禁止的，也许才是真正错误的。如果在大部分时空是不受禁止的，很可能是我们错了。 道貌岸然。用父母给孩子灌输的假想世界与现实世界做对比，找出不能说的话。 机制。观察禁忌和道德观念产生的机制。道德禁忌最大的制造者是那些权力斗争中略占上风的一方。他们有实力推行禁忌，同时又软弱到需要禁忌保护自己的利益。训练自己去想那些不能想的，可以获得超出想法本身的好处。对于发现的“不能说的话”，最好别说，至少要挑选合适的场合再说，只打值得打的仗。自由思考比畅所欲言重要。在别人逼你表态的时候，可以说“我还没想好”。对于值得打的仗，攻击具体的东西，容易授人以把柄。可以 攻击元标签，即抽象描述。 使用隐喻。我们要永远保持质疑的态度。良好的坏习惯黑客不服从管教，追求自由，并有敏锐的感觉。 另一条路：创业之路作者总结了互联网软件相对于桌面软件的各种优势。 迭代发布，功能逐渐变化，减少bug的引入，线上环境，bug很快浮出水面，很快修改。 与用户更紧密的联系。 即时发布让开发人员全力投入。如何创造财富可能最好的办法，就是自己创业或者加入创业公司了。金钱不等于财富。金钱是财富的一种简便表达，但我们的目标是财富。社会总财富是增加的。要致富，需要两样东西 可测量性。职位产生的业绩，应该是可测量的。 可放大性。你的决定能够产生巨大影响。可以用失败的可能性来判断可放大性。没有危险，几乎就没有可放大性。两者必须兼而有之。例如CEO，明星，基金经理，运动员。小团体=可测量性。很难衡量每个人的贡献，但是小团队的贡献，是可测量的。这就是创业公司的真正意义：与更愿意努力工作的人组成一个团队，共同谋取更高的回报。高科技=可放大性。创业公司通过发明新技术盈利。小团队天生就适合解决技术难题。创业也有一些潜规则： 很多事情由不得你。例如竞争对手决定你到底要多辛苦。 创业付出与回报总体上成比例，但是个体上不成比例。对个人来说，付出与回报之间存在一个很随机的放大因子。追求保险，可以早期卖掉自己的创业公司。买家更在乎你的用户数量。要时刻牢记最基本的原则：创造人们需要的东西，即财富。 什么是好设计 好设计是永不过时的设计。 好设计是解决主要问题的设计。 好设计是启发性的设计。 好设计通常是有点趣味性的设计。 好设计是艰苦的设计。 好设计是看似容易的设计。 好设计是对称的设计。 好设计是模仿大自然的设计。 好设计是一种再设计。 好设计是能够复制的设计。 好设计常常是奇特的设计。 好设计是成批出现的。 好设计常常是大胆的设计。 编程语言作者本人非常推崇LISP语言，这里列一下Lisp语言诞生时候就包含的9种新思想 条件结构 函数也是一种数据类型。 递归。 变量的动态类型。 垃圾回收机制。 程序由表达式组成。 符号类型。 代码使用符号和常量组成的树形表示法。 无论什么时候，整个语言都是可用的。 作者认为语言要满足下面几个条件，才能让黑客喜欢上 一种免费的实现 一本相关书籍 语言有它所依附的计算机系统。 简洁 可编程性：能够帮助自己做到想做的事。 善于完成黑客想要完成的各种一次性任务。 函数库。 效率。 经受时间考验。 再设计。作者在这里针对各个接口由不同人负责的情况，除非两个人都同意改变接口，否则接口就无法改变。为了解决这种问题，可以想办法把接口设计成垂直的，而不是水平的。意味着软件内部的模块是一个个垂直堆积起来的抽象层，层与层之间的接口完全由其中一层控制。如果较高一层使用了较低一层定义的语言，那么接口就由较低的一层控制，如果较低一层从属于较高的一层，那么接口就由较高的一层控制。]]></content>
      <tags>
        <tag>原创</tag>
        <tag>读书笔记</tag>
      </tags>
  </entry>
</search>
